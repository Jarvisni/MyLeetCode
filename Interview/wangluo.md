1、HTTPS
是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性；HTTPS 在HTTP 的基础下加入SSL，HTTPS 的安全基础是 SSL；  
HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。HTTPS使用端口443，HTTP则为80；  
HTTP　数据明文传送和缺乏消息完整性检测，攻击者最常用网络嗅探, 从传输过程当中分析出敏感的数据,使用抓包软件即可.HTTP在传输客户端请求和服务端响应时, 唯一的数据完整性检验就是在报文头部包含了本次传输数据的长度, 而对内容是否被篡改不作确认。 攻击者发动中间人攻击, 修改传输的数据甚至插入恶意代码.  
HTTPS 协议是由 HTTP 加上 TLS/SSL 协议构建的可进行加密传输、身份认证的网络协议，主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密。综合利用了非对称加密的安全性和对称加密的快速性。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。  
  
客户端和服务端在传输数据之前,会通过基于X.509证书对双方进行**身份认证**:  
1、客户端C发起 SSL 握手消息给服务端S要求连接。  
2、服务端S将证书发送给客户端C。  
3、客户端C检查服务端证书，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。  
4、服务端S要求客户端C发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥  
  
客户端和服务端在开始传输数据之前，会协商传输过程需要使用的**加密算法**。  
客户端发送协商请求给服务端, 包含自己支持的非对称加密的密钥交换算法 ( RSA), 数据签名摘要算法 ( SHA或者MD5) , 加密传输数据的对称加密算法 ( DES),以及加密密钥的长度。  
服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。
客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。  
  
**防止重放**攻击  
SSL使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个SSL握手中,都有一个唯一的随机数来标记SSL握手。这样防止了攻击者嗅探整个登录过程，直接重传登录数据包的攻击手法。  
  
HTTPS优点：  
认证用户和服务器，确保数据发送到正确的客户机和服务器；  
SSL+HTTP构建的可进行加密传输，比 HTTP安全，可防止数据在传输过程中被窃取、改变，确保数据的完整性；  
缺点：  
页面的加载时间延长，增加耗电，影响缓存，增加数据开销和功耗；  
安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用  
SSL 证书的信用链体系并不安全。特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行  



2、公私钥  
签名和鉴定  
签名的时候用私钥，验证签名的时候用公钥。又因为任何人都可以落款声称她/他就是你，因此公钥必须向接受者信任的人（身份认证机构）来注册。注册后身份认证机构给你发一数字证书。对文件签名后，你把此数字证书连同文件及签名一起发给接受者，接受者向身份认证机构求证是否真地是用你的密钥签发的文件。  
公钥加密系统允许任何人在发送信息时使用私钥进行加密，接收信息时使用公钥解密。  
发送报文时，发送方用一个哈希函数从报文文本中生成报文摘要，然后用发送方的私钥对这个摘要进行加密，这个加密后的摘要将作为报文的数字签名和报文一起发送给接收方，接收方首先用与发送方一样的哈希函数从接收到的原始报文中计算出报文摘要，接着再公钥来对报文附加的数字签名进行解密，如果这两个摘要相同、那么接收方就能确认该报文是发送方的。  
实例：注意签名和加密不一样：  
假如 Alice 向 Bob 传送数字信息，为了保证信息传送的保密性、真实性、完整性和不可否认性，需要对传送的信息进行数字加密和签名，其传送过程为  
Alice 准备好要传送的数字信息（明文）；   
Alice 对数字信息进行哈希运算，得到一个信息摘要；  
Alice **用自己的私钥对信息摘要进行加密**得到 Alice 的数字签名，并将其附在数字信息上；   
Alice 随机产生一个加密密钥，并用此密码对要发送的信息进行加密，形成密文；  
Alice **用 Bob 的公钥对刚才随机产生的加密密钥进行加密**，将加密后的 DES密钥连同密文一起传送给Bob；  
Bob 收到 Alice 传送来的密文和加密过的 DES 密钥，先**用自己的私钥对加密的 DES 密钥进行解密**，得到 Alice随机产生的加密密钥；  
Bob 然后用随机密钥对收到的密文进行解密，得到明文的数字信息，然后将随机密钥抛弃；  
Bob **用 Alice 的公钥对 Alice 的数字签名进行解密**，得到信息摘要；  
Bob 用相同的哈希算法对收到的明文再进行一次哈希运算，得到一个新的信息摘要；  
Bob 将收到的信息摘要和新产生的信息摘要进行比较，如果一致，说明收到的信息没有被修改过。  
  
3、SSL  
SSL安全套接字协议 及其继任者 传输层安全TLS 是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层与应用层之间对网络连接进行加密。  
SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。  
SSL协议可分为两层：   
SSL记录协议 建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。   
SSL握手协议 建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。  
  
4、非对称加密算法  
非对称加密算法实现机密信息交换的基本过程是：  
A生成一对密钥并将公钥公开，B使用该密钥A的公钥对机密信息进行加密后再发送给A；A再用自己私钥对加密后的信息进行解密。  
A想要回复B时正好相反，使用B的公钥对数据进行加密，同理，B使用自己的私钥来进行解密。  
另一方面，A可以使用自己的私钥对机密信息进行签名后再发送给B；B再用A的公钥对发送回来的数据进行验签。  
非对称密码体制的特点：  
算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制消除了用户交换密钥的需要。这样安全性就大了很多。  
实例：  
Alice需要通过电子邮件给Bob发送一个机密文档。首先，Bob使用电子邮件将自己的公钥发送给Alice。然后Alice用Bob的公钥对文档加密并通过电子邮件将加密消息发送给Bob。由于任何用Bob 的公钥加密的消息只能用Bob的私钥解密，因此即使窥探者知道Bob的公钥，消息也仍是安全的。Bob在收到加密消息后，用自己的私钥进行解密从而恢复原始文档。  

  
5、TCP如何保障可靠性：  
TCP协议支持数据报传输可靠性的主要方法是确认、超时、重传、校验和以及流量控制。  
（1）16bit校验和，用来检查报文段是否出现传输错误，如果报文段出现传输错误，TCP检查出错就丢弃该报文段。  
（2）确认——接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。接收端检查报文是否出错，发现出错时就丢弃，不发确认；而发送端TCP就通过检查接收端的确认，判断发送的报文段是否已经正确到达目的地。  
（3）超时——为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；并为每个已发送的数据包启动一个超时定时器；如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。发送端根据发出的报文段在超时规定的时间内是否收到确认，从而来判断该报文段是否丢失或传输出错。TCP使用了4种计时器:重传计时器、坚持计时器、保持计时器和时间等待计时器来保证了传输的可靠性。  
（4）TCP还能提供流量控制。TCP报文段首部中有16bit接收窗口大小。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。TCP使用的流量控制协议是可变大小的滑动窗口协议。  
（5）拥塞控制。  
  
6、流量控制与拥塞控制：  
（1）流量控制：需要消除发送方使得接收方缓存溢出的可能，使之速度相匹配。A向B发送。接收端应答的TCP报文段首部中含有rwnd接收窗口大小字段，告知A当前接收窗口大小，A需要保证LastByteSent-LastByteAcked<=Rwnd  
A<-B ack rwnd=300  
...  
A<-B ack rwnd=100  
...  
A<-B ack rwnd=0  
当A知道B中接收窗口没有空余时，开始启动一个持续计时器，周期性发送一个字节长度的报文段来探测是否有空间，B在确认此报文时给出窗口大小。  
周期性发一字节是因为可能B通知A有空间的报文段会丢失导致A不知道B有空了而一直等待。  
（2）拥塞控制：发送方因为网络拥塞而被遏制，是端到端的拥塞控制，此时网络层没有显式支持，另有网络辅助拥塞控制。  
发送方维护一个拥塞窗口cwnd，门限ssthresh，发送窗口=拥塞窗口，发送窗口的上限为Min(cwnd,rwnd),并且LastByteSent-LastByteAcked<=Min(Cwnd,Rwnd)  
**慢启动，拥塞避免，快速重传，快速恢复**  
慢启动：开始时cwnd=1MSS，之后收到一个ACK就+1MSS，在一个RTT中收到多个ACK而cwnd会翻倍：cwnd=1，2，4，8...  
拥塞避免：cwnd达到门限值是开始拥塞避免，一个RTT中cwnd+1MSS  
当出现拥塞时（1、超时丢包，门限=1/2当前cwnd 2、连续三个重复ACK，门限=1/2当前cwnd+3MSS）  
有两种方式：1、Tahoe，旧的：cwnd=1，再开始慢启动达到当前门限后拥塞避免 2、Reno：cwnd=当前门限即一半加3，直接拥塞避免  
快重传：即发送方尽快重传，而不是登海超时计时器超时再重传。接受方立即发送确认，收到失序报文段也要对已接受的报文段重复确认，发送方收到三个连续重复确认就将对应报文段立即重传。  
快恢复：即收到三个重复确认知道丢失了个别报文段，于是执行快恢复，设为一半+3后拥塞避免而不是设为1  
  
  
7、为什么三次握手四次挥手？  
（1）三次握手  
第一次握手：C发包，S收到了。  
C的发送能力、S的接收能力是正常的。  
第二次握手：S发包，C收到了。  
S的接收、发送能力，C的发送能力是正常的。此时S并不能确认C的接收能力是否正常。  
第三次握手：C发包，S收到了。  
C的接收、发送能力正常，S的接受、发送能力正常。  
因此，需要三次握手才能确认双方的接收与发送能力是否正常。  
**假如两次握手**  
C发出连接请求，但因连接请求报文丢失而未收到确认，于是C再重传一次连接请求。  
后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，C共发出了两个连接请求报文段，第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的才到达服务端，此时S误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，若不采用三次握手，只要服务端发出确认，就建立新的连接了，此时C忽略服务端发来的确认，也不发送数据，则服务端等待客户端发送数据，浪费资源。  
**半连接队列**  
S第一次收到C的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。  
SYN-ACK 重传次数的问题：S发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。每次重传等待的时间不一定相同，一般会是指数增长。  
**三次握手携带数据**  
其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据  
假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据重复发 SYN 报文的话，会让服务器花费很多时间、内存空间来接收这些报文。  
三次握手最后一个消息是客户端发过来的ACK，如果让应用层数据与这个信令数据合二为一，可以减少发送的IP包的数目，还可以提高效率。  
第三次客户端发送这个报文之后，就进入established状态了。服务器收到这个报文之后，也进入established状态。TCP标准规定，第三次握手的报文，可以携带数据。因为此时客户端已经处于established状态了呀。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了。  
假设第三次握手的报文的seq是x+1，如果有携带数据，下次客户端发送的报文，seq=服务器发回的ACK号。如果没有携带数据，那么第三次握手的报文不消耗seq。下次客户端发送的报文，seq序列号还是和第三次握手的报文的seq一样，为x+1。这是因为，seq和报文中的数据在整条数据流流中的位置是一一对应的。如果报文没有携带数据，那么seq当然也不会更新。  
**握手丢失**  
第一个丢失，C会周期性超时重传直到收到S确认。  
第二个丢失，S会周期性超时重传直到收到C确认。  
第三个丢失，C发完就进入established状态，而S还并非位于。  
1、双方没有数据要发，则S周期性超时重传直到收到C确认，S收到后就切换到established。2、C要发数据，S收到C发的data和ack就切换到established。3、S要发数据无法发送一直周期性超时重传SYN和ACk即第二个，直到收到C确认。  
**SYN攻击**  
服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。  
SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。  
检测 SYN 攻击，在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。Linux上使用系统自带的 netstats 命令来检测 SYN 攻击。  
防御 SYN 攻击的方法有如下几种：  
缩短超时（SYN Timeout）时间、增加最大半连接数、过滤网关防护、SYN cookies技术  
（2）四次挥手  
这由TCP的半关闭（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。  
客户端或服务器均可主动发起挥手动作。刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：  
第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。  
第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。  
第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。  
第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。**此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。**  
  
收到一个FIN只意味着在这一方向上没有数据流动。客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。  
在socket编程中，任何一方执行close()操作即可产生挥手操作。关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。  
**每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。**  
  
**停留2MSL目的：**  
保证客户端发送的最后一个ACK报文段能够到达服务端。客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。  
为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。  
  
  
  
  
  
  
  
  
参考：  
1、https://www.zhihu.com/question/66407996?sort=created 范开喜  
2、https://zhuanlan.zhihu.com/p/354282525  
3、  
