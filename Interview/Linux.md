1、top  
top命令经常用来监控linux的系统状况，是常用的性能分析工具，能够实时显示系统中各个进程的资源占用情况。查看CPU、内存状态。  
-d number 秒数，表示top命令显示的页面更新一次的间隔。默认是5秒。  
-p：指定特定的pid进程号进行观察  
top页面下输入命令 P：以CPU的使用资源排序显示 M：以内存的使用资源排序显示 N：以pid排序显示 T：由进程使用的时间累计排序显示 k：给某一个pid一个信号。可以用来杀死进程  
  
2、grep  
用于查找文件里符合条件的字符串  
系统报警显示了时间，但是日志文件太大无法直接 cat 查看。(查询含有特定文本的文件，并拿到这些文本所在的行)  
解决：grep -n '2019-10-24 00:01:11'  * .log  
从文件内容查找匹配指定字符串的行：$ grep "被查找的字符串" 文件名  
从文件内容查找不匹配指定字符串的行： $ grep –v "被查找的字符串" 文件名  
  
3、软硬链接  
文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。  
用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分 但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。而有一种方法可以快速的寻找到数据元，那就是软硬链接。  
从使用的角度讲，都与正常的文件访问方式一样支持读写，如果是可执行文件的话也可以直接执行。  
$ ln myfile hard  
$ ls -li  
25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 hard  
25869085 -rw-r--r-- 2 unixzii staff 27 7 8 17:39 myfile  
这两个文件就如同一个文件一样，inode 值相同，都指向同一个区块。对hard添加文字也会执行在myfile上，说明两个文件就是一个文件。  
$ ln -s myfile soft  
$ ls -li  
25869085 -rw-r--r-- 2 unixzii staff 36 7 8 17:45 hard  
25869085 -rw-r--r-- 2 unixzii staff 36 7 8 17:45 myfile  
25869216 lrwxr-xr-x 1 unixzii staff 6 7 8 17:47 soft -> myfile  
软链接的 inode 不一样，并且它的文件属性上有一个 l 的flag，这就说明它与之前我们创建的两个文件根本不是一个类型。  
删除 myfile 文件，然后分别输出软硬链接的文件内容：硬链接没有丝毫地影响，因为它 **inode 所指向的区块**由于有一个硬链接在指向它，所以这个区块仍然有效，并且可以访问到。软链接的 inode 所指向的内容实际上是保存了一个**绝对路径**，当用户访问这个文件时，系统会自动将其替换成其所指的文件路径，然而这个文件已经被删除了，所以自然就会显示无法找到该文件了。我们再向这个软链接写点东西：$ echo "Something" >> soft ，$ ls 出现hard myfile soft 可以看到，刚才删除的 myfile 文件又出现了，这就说明，当我们写入访问软链接时，系统自动将其路径替换为其所代表的绝对路径，并直接访问那个路径。  
硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块  
软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径  
  
  
4、守护进程  
守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。  
守护进程是一个在后台运行并且不受任何终端控制的进程。它们在后台运行，执行不同的管理任务。守护进程没有控制终端，因此当某些情况发生时，不管是一般的报告性信息，还是需由管理员处理的紧急信息，都需要以某种方式输出。Syslog 函数就是输出这些信息的标准方法，它把信息发送给 syslogd 守护进程。  
守护进程是脱离控制终端的，因此首先创建子进程，终止父进程，使得程序在shell终端里造成一个已经运行完毕的假象。之后所有的工作都在子进程中完成，而用户在shell终端里则可以执行其他的命令，从而使得程序以僵尸进程形式运行，在形式上做到了与控制终端的脱离。  
  
5、僵尸进程  
一个进程结束了，但是他的父进程没有等待(调用wait / waitpid)他， 那么他将变成一个僵尸进程。 但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程， 因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程， 看有没有哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由Init 来接管他，成为他的父进程.  
在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位 置，记载该进程的退出状态等信息供其他进程收集。除此之外，僵尸进程不再占有任何内存空间。它需要它的父进程来为它收尸，如果他的父进程没安装 SIGCHLD 信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时父进程结束了， 那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是 为什么系统中有时会有很多的僵尸进程。  
利用命令ps，可以看到有父进程ID为1的进程是孤儿进程；s(state)状态为Z的是僵尸进程。注意：孤儿进程(orphan process)是尚未终止但已停止(相当于前台挂起)的进程，但其父进程已经终止，由init收养；而僵尸进程则是已终止的进程，其父进程不一定终止。  
清除僵尸进程：(1)改写父进程，在子进程死后要为它收尸。具体做法是接管SIGCHLD信号。子进程死后， 会发送SIGCHLD信号给父进程，父进程收到此信号后，执行 waitpid()函数为子进程收尸。(2)把父进程杀掉。父进程死后，僵尸进程成为"孤儿进程"，过继给1号进程init，init始终会负责清理僵尸进程，关机或重启后所有僵尸进程都会消失。(3)fork两次，父进程fork一个子进程，然后继续工作，子进程fork一 个孙进程后退出，那么孙进程被init接管，孙进程结束后，init会回收。不过子进程的回收 还要自己做。  
  
  
6、rwx权限  
chmod abc file，其中a,b,c各为一个数字，分别表示User、Group、Other的权限。  
r=4，w=2，x=1  u所有者 g所有组、所有者同组用户 o其他用户 a所有人  
r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录信息的权限。  
w(Write,写入)：对文件而言，具有新增,修改文件内容的权限(但不含删除该文件)；对目录来说，具有新建，删除，修改，移动目录内文件的权限。  
x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。  
-rwxrwxrwx  
首先-代表是个普通文件，区别于d目录和l链接；  
接下来三个一组，分别代表文件持有者(用户)，文件归属组 和 其他非在组中的用户对于该文件的权限；  
第三r代表读 w代表写 x代表执行。  
  
  
7、docker和虚拟机区别  
虚拟机技术通过Hypervisor层抽象底层基础设施资源，提供相互隔离的虚拟机，通过统一配置、统一管理，资源的可运维性以及资源利用率都能够得到有效的提升； 虚拟机提供客户机操作系统，客户机变化不会影响宿主机，能够提供可控的测试环境，更能够屏蔽底层硬件甚至基础软件的差异性，让应用做到的广泛兼容 ； 不可避免地出现性能损失，因为要运行一个完整的客户机操作系统。  
容器解决的核心问题是应用开发、测试和部署。没有客户机操作系统，是共享内核的。容器可以视为软件供应链的集装箱，能够把应用需要的运行环境、缓存环境、数据库环境等等封装起来，以最简洁的方式支持应用运行。因为共享内核，容器隔离性也没有虚拟机那么好。通过Docker的特性，以容器化封装为基础，让应用快速上线、快速迭代。将系统拆分成多个服务，每个部分都可以独立开发测试部署，同时我们也可以只扩展需要扩展的部分。  
  
虚拟化的实现：  
虚拟机实现资源的隔离的方式是利用独立的Guest OS，以及利用Hypervisor虚拟化CPU、内存、IO等设备来实现的。  
Docker并没有和虚拟机一样利用一个独立的Guest OS执行环境的隔离，它利用的是Linux内核本身支持的容器方式，实现了资源和环境的隔离，简单来说Docker就是利用Namespace 实现系统环境的隔离，利用cgroup实现资源的限制，利用镜像实例实现环境的隔离。  
  
资源的控制：  
vm与docker框架，直观上来讲vm多了一层guest OS；Hypervisor会对硬件资源进行虚拟化，Hypervisor可以理解为硬件虚拟化平台，它在Host OS以内核驱动的形式存在。  
Docker不需要Hypervisor实现硬件资源的虚拟化，运行在Docker容器上的程序直接使用的都是实际物理机的硬件资源，Docker将会在效率上具有更大的优势。  
Docker直接利用虚拟机的系统内核，避免了虚拟机启动时所需要的系统引导时间和操作系统运行的资源消耗，利用Docker能够在几秒钟之内启动大量的容器，是虚拟机无法办到的。  
快速启动低资源消耗的优点，它能够快速的交付和部署，例如开发者可以使用一个标准镜像构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码，Docker可以快速创建容器快速迭代应用程序，整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。  
容器的启动时间是秒级的，节约开发、测试、部署的时间。Docker能够高效地部署和扩容，Docker容器几乎可以在任意平台上运行，兼容性和轻量性，应用性能高，系统开销小。  
  
  
部分来源：  
1、https://www.zhihu.com/question/48174633/answer/218092411  
2、https://www.zhihu.com/question/48174633/answer/568562893  
3、  
