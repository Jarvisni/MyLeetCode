**1、map hash_map unordered_map**  
**map**是STL的一个关联容器，它提供一对一的hash,第一个为关键字(key)，每个关键字只能在map中出现一次；第二个为值(value)；map以模板泛型方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。有序性是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作,内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高。缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间。  
Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗**红黑树**，这颗树具有**对数据自动排序**的功能。在map内部所有的数据都是有序的。  
  
**hash_map**基于哈希表，空间换时间，数据存储和查找耗时降低，几乎常数时间，内存消耗增加。使用一个下标范围比较大的数组来存储元素。可以设计一个哈希函数，使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。因为内部实现了哈希表，因此其查找速度非常的快。缺点： 哈希表的建立比较耗费时间。适用于查找问题，unordered_map会更加高效一些。红黑树 VS hash表 , 还是unorder_map占用的内存要高，但是unordered_map执行效率要比map高很多  
需要**解决冲突**：1， 开放定址法 2， 再哈希法 3， 链地址法 4、建立公共溢出区  
开放定址法的增量 d 可以有不同的取法，根据增量可以分为线性探测再散列、二次探测再散列(k^2， -k^2)、伪随机再散列
链地址法好处：不会产生堆积，适合无法确定表长的情况，但是会增加空间消耗（指针需要空间）
hash_map首先分配一大片内存，形成许多桶。利用hash函数，对key进行映射到不同区域（桶）进行保存。其插入过程是：  
得到key  
通过hash函数得到hash值  
得到桶号(一般都为hash值对桶数求模)  
存放key和value在桶内  
  
其取值过程是:  
得到key  
通过hash函数得到hash值  
得到桶号(一般都为hash值对桶数求模)  
比较桶的内部元素是否与key相等，若都不相等，则没有找到  
取出相等的记录的value  
  
hash_map中直接地址用hash函数生成，解决冲突，用比较函数解决   
由此可见，要实现哈希表, 和用户相关的是：**hash函数**和**比较函数**。这两个参数刚好是我们在使用hash_map时需要指定的参数  
没有指定hash函数和比较函数的时候，会有一个缺省的函数。但有的key类型不可以使用默认的函数，比如string  
**速度**：hash_map **查找速度**会比map快，而且查找速度基本和数据数据量大小，属于常数级别;而map的查找速度是log(n)级别。**并不一定常数就比log(n)小**，hash还有**hash函数**的耗时，如果考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时，你就更无法控制了，而且hash_map的**构造速度**较慢。  
权衡三个因素: 查找速度, 数据量, 内存使用  
  
为什么用红黑树而不是AVL来进行map，已经有了AVL为什么还要map呢？  
While in both algorithms the insert/delete operations are O(log n), in the case of Red-Black tree re-balancing rotation is an O(1) operation while with AVL this is a O(log n) operation, making the Red-Black tree more efficient in this aspect of the re-balancing stage and one of the possible reasons that it is more commonly used.
  
  
**2、快排**  
从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即j=10），指向数字8。  
其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。每次必须是哨兵j先出发。  
当基准数选择最左边的数字时，那么就应该先从右边开始搜索；当基准数选择最右边的数字时，那么就应该先从左边开始搜索。不论是从小到大排序还是从大到小排序！  
最差时间复杂度和冒泡排序是一样的都是O(N2)，它的平均时间复杂度为O(NlogN)。  
```C++
//快速排序（从小到大）
void quickSort(int left, int right, vector<int>& arr)
{
	if(left >= right)
		return;
	int i, j, base, temp;
	i = left, j = right;
	base = arr[left];  //取最左边的数为基准数
	while (i < j)
	{
		while (arr[j] >= base && i < j)
			j--;
		while (arr[i] <= base && i < j)
			i++;
		if(i < j)
		{
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = temp;
		}
	}
	//基准数归位
	arr[left] = arr[i];
	arr[i] = base;
	quickSort(left, i - 1, arr);//递归左边
	quickSort(i + 1, right, arr);//递归右边
}
```
  
  
  
**3、各种树以及操作的复杂度**：  
**二叉树：**   
查找时间复杂度：最好Olgn,最差On。最差情况所有的数据全在一端。  
**二叉搜索树（二叉排序树、二叉查找树）：**  
查找时间复杂度：最好Olgn,最差On。最差情况所有的数据全在一端。  
**平衡二叉树AVL：**  
查找时间复杂度：Olgn，所有节点的左右子树高度差不能超过1；实现平衡的关键在于旋转操作，旋转的量级为O(lgn)。旋转的耗时使AVL树在删除数据时效率很低；在删除操作较多时维护平衡所需的代价可能高于其带来的好处。  
**红黑树：**  
查找删除插入时间复杂度：Olgn  
红黑树是一种复杂的自平衡的二叉排序树，有着良好的最坏情况运行时间，并且高效的在O(logn)时间内做查找，插入和删除，这里的n是树中元素的数目。与AVL树相比，红黑树的查询效率会有所下降，这是因为树的平衡性变差，高度更高。但红黑树的删除效率大大提高了，因为红黑树同时引入了颜色，当插入或删除数据时，只需要进行O(1)次数的旋转以及变色就能保证基本的平衡，不需要像AVL树进行O(lgn)次数的旋转。对于数据在内存中的情况如HashMap，红黑树的表现是非常优异的。但是对于数据在磁盘等辅助存储设备中的情况（如MySQL等数据库），红黑树并不擅长，因为红黑树长得还是太高了。当数据在磁盘中时，磁盘IO会成为最大的性能瓶颈，设计的目标应该是尽量减少IO次数；而树的高度越高，增删改查所需要的IO次数也越多，会严重影响性能。因此需要B树。  
红黑树性质：  
红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树的基础上增加如下要求:
性质1. 节点是红色或黑色。  
性质2. 根是黑色。  
性质3. 所有叶子都是黑色（叶子是NIL节点）。  
性质4. 每个红色节点必须有两个黑色的子节点。(从每个叶子到根的所有路径上不能有两个连续的红色节点。)  
性质5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。
确保了红黑树的关键特性: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。  
红黑树是平衡二叉树，通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，确保没有一条路径会比其他路径长2倍，因而是近似平衡的。所以相对于严格要求平衡的AVL树来说，它的旋转保持平衡次数较少。用于搜索时，插入删除次数多的情况下我们就用红黑树来取代AVL。  
**B-树：**  
一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，节点最大的孩子数目称为B树的阶。B树（B-tree）是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在**对数时间**内完成。B树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。B树所有叶子结点位于同一层，每个节点最多包含 m 个子节点。如果根节点包含子节点，则至少包含 2 个子节点；除根节点外，每个非叶节点至少包含 m/2 个子节点。拥有 k 个子节点的非叶节点将包含 k - 1 条记录。所有叶节点都在同一层中。还有对访问局部性原理的利用：当一个数据被使用时，其附近的数据有较大概率在短时间内被使用，B树将键相近的数据存储在同一个节点，当访问其中某个数据时，数据库会将该整个节点读到缓存中；当它临近的数据紧接着被访问时，可以直接在缓存中读取，无需进行磁盘IO；换句话说B树的缓存命中率更高。B树在数据库中如mongodb的索引使用了B树结构。
**B+树：**  
B+树是B树的变体，也是一种多路搜索树。B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），非叶子节点相当于是叶子节点的索引(稀疏索引),叶子节点相当于是存储(关键字)数据的数据层. 其性能也等价于在关键字全集做一次二分查找；更适合文件索引系统。B树中每个节点（包括叶节点和非叶节点）都存储真实的数据，B+树中只有叶子节点存储真实的数据，非叶节点只存储键。在MySQL中这里所说的真实数据，可能是行的全部数据（如Innodb的聚簇索引）也可能只是行的主键（如Innodb的辅助索引）或者是行所在的地址（如MyISAM的非聚簇索引）。B树中一条记录只会出现一次，不会重复出现，而B+树的键则可能重复重现----一定会在叶节点出现，也可能在非叶节点重复出现。B+树的叶节点之间通过双向链表链接。B树中的非叶节点，记录数比子节点个数少1；而B+树中记录数与子节点个数相同。  
B+树与B树相比，有以下**优势：**  
更少的IO次数：B+树的非叶节点只包含键而不含真实数据，因此每个节点存储的记录个数比B数多很多（即阶m更大），因此B+树的高度更低，访问时所需要的IO次数更少。此外，由于每个节点存储的记录数更多，所以对访问局部性原理的利用更好，缓存命中率更高。  
更适于范围查询：在B树中进行范围查询时，首先找到要查找的下限，然后对B树进行中序遍历，直到找到查找的上限；而B+树的范围查询，只需要对链表进行遍历即可。  
更稳定的查询效率：B树的查询时间复杂度在1到树高之间(分别对应记录在根节点和叶节点)，而B+树的查询复杂度则稳定为树高，因为所有数据都在叶节点。  
B+树也存在**劣势：** 由于键会重复出现，因此会占用更多的空间。但是与带来的性能优势相比，空间劣势往往可以接受，因此B+树的在数据库中的使用比B树更加广泛。  
**不用普通二叉树做索引：**  
考虑磁盘I/O的影响，它相对于内存来说是很慢的。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。所以要减少IO次数，对于树来说，IO次数就是树的高度，而“矮胖”就是B树的特征之一，它的每个节点最多包含m个孩子，m称为b树的阶，m的大小取决于磁盘页的大小。  
**为什么B+树比B树更适合文件索引和数据索引**  
B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对于B-树更小，如果把所有同一内部节点的关键字放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存所需要查找的关键字也就越多，相对IO读写次数就降低了。  
B树在提高了I/O性能的同时并没有解决元素遍历的我效率低下的问题,正是为了解决这个问题,B+树应用而生.B+树只需要去遍历叶子节点就可以实现整棵树的遍历.而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）.B+树的中间节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖”；
B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，因此B+树查找更稳定（并不慢）；对于范围查找来说，B+树只需遍历叶子节点链表即可，B树却需要重复地中序遍历。**在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作索引结构**。  
**两种mysql引擎**  
在MySQL中，无论是Innodb还是MyIsam，都使用了B+树作索引结构。  
Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别。还提供了行级锁和外键约束，它的设计目标是处理大容量数据库系统，它本身其实就是基于MySQL后台的完整数据库系统，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(* ) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。  
MyISAM引擎是MySQL默认的引擎，没有提供对数据库事务的支持，不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyISAM中存储了表的行数，于是SELECT COUNT(* ) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyISAM也是很好的选择。  
  
  
**4、vector底层实现：**  
其底层所采用的数据结构非常简单，就只是一段连续的线性内存空间。使用 3 个迭代器（可以理解成指针）来表示的：_Myfirst 指向的是 vector 容器对象的起始字节位置；_Mylast 指向当前最后一个元素的末尾字节；_myend 指向整个 vector 容器所占用内存空间的末尾字节。灵活运用这 3 个迭代器，vector 容器可以轻松的实现诸如首尾标识、大小、容器、空容器判断等几乎所有的功能。当 vector 的大小和容量相等（size==capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步：  
完全弃用现有的内存空间，重新申请更大的内存空间；  
将旧内存空间中的数据，按原有顺序移动到新的内存空间中；  
最后将旧的内存空间释放。  
这也就解释了为什么 vector 容器在进行扩容后，与其相关的指针、引用以及迭代器可能会失效。由此可见，vector 扩容是非常耗时的，为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity>=size），以便后期使用。vector 容器扩容时，不同的编译器申请更多内存空间的量是不同的。以 VS 为例，它会扩容现有容器容量的 50%。  

  
部分来源：  
1、https://blog.csdn.net/qq_33216029/article/details/96470266  
2、https://blog.csdn.net/qq_28584889/article/details/88136498  
3、https://www.jianshu.com/p/d5dd618014f0  
4、https://blog.csdn.net/printwsl/article/details/80058841  
5、https://blog.csdn.net/weixin_32121931/article/details/112125179  
