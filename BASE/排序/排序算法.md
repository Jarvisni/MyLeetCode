1、时间复杂度为 O(n^2)的排序算法:  
冒泡排序  
选择排序  
插入排序  
希尔排序 (希尔排序比较特殊，它的性能略优于 O(n^2)但又比不上O(nlog n)，姑且把它归入本类)  
2、时间复杂度为O(nlog n) 的排序算法  
快速排序  
归并排序  
堆排序  
3、时间复杂度为线性的排序算法  
计数排序  
桶排序  
基数排序  
  
根据排序算法的稳定性，如果值相同的元素在排序后仍然保持着排序前的顺序，则这样的排序算法是稳定排序；如果值相同的元素在排序后打乱了排序前的顺序，则这样的排序算法是不稳定排序。  
  
快速排序：  
Pivot法：O(n)  
参考数选择a[0]的情况下，后面定义两个指针 i 和 j ，分别指向除了参考数之外的第一个和最后一个元素。首先对 i 指针从左往右扫描，直到碰到第一个比 5 大的数停下来。对 j 指针从右往左扫描，直到碰到第一个比 5 小的数停下来。当i和j重合的时候：  
如果重合位置数大于参考数，交换 a[i-1] 和 a[0]。  
如果重合位置数小于等于参考数，交换 a[i] 和 a[0]。  
在快速排序时，首先，我们调用 Pivot 算法，将参考数放在合适的位置。对于参考数来说，参考数左边的数都小于他，右边的数都大于他。所以我们可以对左右部分递归调用 Pivot 算法，最后就能得到有序数组了。
如果参考数每次都处于中间位置，计算次数是nlog(n)级别的。如果参考数位置不当，快速排序的时间复杂度最终会退化为 O(n^2)  
如果数据本身是随机打乱的话，仍然可以放心使用快速排序算法。或者修改一下参考数的选择策略：随机选择任意一个数作为参考数，然后们将这个数和第一个数交换，继续套用之前，原始排列很难影响到算法了。快速排序递归调用系统栈，空间复杂度为 O(logn)O(logn)  
  
基数排序（桶排序）：  
首先按个位桶排序，那么现在所有的数据都保持个位上有序。  
然后按十位桶排序，数据在十位上是有序的。单独看每个桶内数据保持之前顺序，因此桶内数据在个位上也是有序的。即桶内数据在后两位有序。  
按百位排序时，桶内数据 在后三位是有序的。  
最后，所有位数排完时，桶内数据是有序排列，加上桶本身按最高位顺序排序，因此所有数据都有序了。  
由于我们排序每一位都需要遍历一遍数据，所以整体时间复杂度为 O(n)。需要一个额外的 O(n)桶空间。基数排序的理论时间复杂度更低，但依赖于排序的数据x的位数即等价于 log(x)，因此基数排序的常数log(x)和快速排序多出来的复杂度部分 log(n)实际上是一个量级，并不能得到一个绝对的速度优势。  
桶排序需要对数据有严格的限制才能适用，对于普通数据的排序一般还是使用其他稳定或者非稳定的O(nlogn)复杂度的排序算法。  
